apiVersion: batch/v1
kind: Job
metadata:
  name: setup-root-ca
  namespace: cert-manager
  annotations:
    argocd.argoproj.io/sync-wave: "-1"
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  template:
    spec:
      serviceAccountName: setup-root-ca
      containers:
      - name: setup-root-ca
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - /scripts/setup-root-ca.sh
        volumeMounts:
        - name: scripts
          mountPath: /scripts
      volumes:
      - name: scripts
        configMap:
          name: setup-root-ca-script
          defaultMode: 0755
      restartPolicy: OnFailure
  backoffLimit: 3
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: setup-root-ca
  namespace: cert-manager
  annotations:
    argocd.argoproj.io/sync-wave: "-2"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: setup-root-ca
  annotations:
    argocd.argoproj.io/sync-wave: "-2"
rules:
- apiGroups: [""]
  resources: ["secrets", "namespaces"]
  verbs: ["get", "list", "create", "update", "patch"]
- apiGroups: ["cert-manager.io"]
  resources: ["clusterissuers"]
  verbs: ["get", "list", "create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: setup-root-ca
  annotations:
    argocd.argoproj.io/sync-wave: "-2"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: setup-root-ca
subjects:
- kind: ServiceAccount
  name: setup-root-ca
  namespace: cert-manager
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: setup-root-ca-script
  namespace: cert-manager
  annotations:
    argocd.argoproj.io/sync-wave: "-2"
data:
  setup-root-ca.sh: |
    #!/bin/bash
    set -e

    echo "üîê Setting up Root CA for bitsb.dev domain..."

    # Function to create ClusterIssuer
    create_cluster_issuer() {
        echo "üóÇÔ∏è Creating ClusterIssuer for Root CA..."
        
        # Create ClusterIssuer that uses the Root CA
        cat << EOF | kubectl apply -f -
    apiVersion: cert-manager.io/v1
    kind: ClusterIssuer
    metadata:
      name: bitsb-root-ca-issuer
      labels:
        app.kubernetes.io/managed-by: bitsb-automation
    spec:
      ca:
        secretName: bitsb-root-ca
    EOF
    }

    # Check if root CA secret already exists
    if kubectl get secret bitsb-root-ca -n cert-manager >/dev/null 2>&1; then
        echo "‚úÖ Root CA secret 'bitsb-root-ca' already exists in cert-manager namespace"
        
        # Also check if ClusterIssuer exists
        if kubectl get clusterissuer bitsb-root-ca-issuer >/dev/null 2>&1; then
            echo "‚úÖ ClusterIssuer 'bitsb-root-ca-issuer' already exists"
            echo "üéâ Root CA setup is already complete!"
            exit 0
        else
            echo "‚ö†Ô∏è  Secret exists but ClusterIssuer missing. Creating ClusterIssuer..."
            create_cluster_issuer
            echo "üéâ Root CA setup completed!"
            exit 0
        fi
    else
        echo "üìú Creating Root CA certificate and private key..."
    fi

    # Create temporary directory for certificate generation
    CERT_DIR="/tmp/bitsb-ca-$(date +%s)"
    mkdir -p "$CERT_DIR"
    cd "$CERT_DIR"

    # Generate Root CA private key
    openssl genrsa -out ca.key 4096

    # Create Root CA certificate
    cat > ca.conf << EOF
    [ req ]
    distinguished_name = req_distinguished_name
    x509_extensions = v3_ca
    prompt = no

    [ req_distinguished_name ]
    C = US
    ST = California
    L = San Francisco
    O = BitSB Development
    OU = Infrastructure
    CN = BitSB Root CA
    emailAddress = admin@bitsb.dev

    [ v3_ca ]
    basicConstraints = critical,CA:TRUE
    keyUsage = critical, digitalSignature, cRLSign, keyCertSign
    subjectKeyIdentifier = hash
    authorityKeyIdentifier = keyid:always,issuer
    EOF

    # Generate Root CA certificate (valid for 10 years)
    openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -config ca.conf -extensions v3_ca

    echo "üîç Root CA Certificate Information:"
    openssl x509 -in ca.crt -text -noout | grep -E "(Subject|Validity|CN|DNS)" || true

    echo "üîß Creating Kubernetes secret for Root CA..."

    # Create cert-manager namespace if it doesn't exist
    kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -

    # Create the Root CA secret in cert-manager namespace
    kubectl create secret tls bitsb-root-ca \
        --cert=ca.crt \
        --key=ca.key \
        -n cert-manager

    # Label the secret for cert-manager
    kubectl label secret bitsb-root-ca -n cert-manager \
        cert-manager.io/root-ca=true \
        app.kubernetes.io/managed-by=bitsb-automation

    # Create the ClusterIssuer
    create_cluster_issuer

    # Cleanup temporary files
    cd /
    rm -rf "$CERT_DIR"

    echo "üéâ Root CA setup completed!"
